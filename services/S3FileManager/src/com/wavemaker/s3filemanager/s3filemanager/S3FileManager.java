/*Generated by WaveMaker Studio*/
package com.wavemaker.s3filemanager.s3filemanager;

import javax.servlet.http.HttpServletRequest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import com.wavemaker.runtime.security.SecurityService;
import com.wavemaker.runtime.service.annotations.ExposeToClient;
import com.wavemaker.runtime.service.annotations.HideFromClient;
import org.springframework.beans.factory.annotation.Value;
import com.wavemaker.connector.awss3connector.S3Connector;
import org.springframework.web.multipart.MultipartFile;
import java.io.IOException;
import com.wavemaker.runtime.commons.file.model.DownloadResponse;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import com.wavemaker.connector.awss3connector.AWSS3ObjectSummary;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.nio.file.Files;
import java.io.File;
import java.io.*;
import java.io.FileOutputStream;
import com.opencsv.CSVReader;
import com.opencsv.exceptions.CsvException;
import java.util.Date;
import com.wavemaker.s3filemanager.s3filemanager.model.S3ObjectSummaryWrapper;






//import com.pramati.pmo.s3fileupload.model.*;

/**
 * This is a singleton class with all its public methods exposed as REST APIs via generated controller class.
 * To avoid exposing an API for a particular public method, annotate it with @HideFromClient.
 *
 * Method names will play a major role in defining the Http Method for the generated APIs. For example, a method name
 * that starts with delete/remove, will make the API exposed as Http Method "DELETE".
 *
 * Method Parameters of type primitives (including java.lang.String) will be exposed as Query Parameters &
 * Complex Types/Objects will become part of the Request body in the generated API.
 *
 * NOTE: We do not recommend using method overloading on client exposed methods.
 */
@ExposeToClient
public class S3FileManager {

    private static final Logger logger = LoggerFactory.getLogger(S3FileManager.class);

    @Autowired
    private SecurityService securityService;
    @Autowired
    private S3Connector s3Connector;
    
    @Value("${app.environment.s3.bucket.name}")
    private String S3_BUCKET_NAME;
    
    @Value("${app.environment.s3.region.domain}")
    private String S3_REGION_NAME;
    
    @Value("${app.environment.photos.prefix}")
    private String PHOTOS_PREFIX;
     @Value("${app.environment.icon.prefix}")
    private String ICONS_PREFIX;

    private static final List<String> IMAGE_EXTENSIONS = Arrays.asList("png", "jpg", "jpeg", "gif", "svg", "bmp", "tiff");
    /**
     * This is sample java operation that accepts an input from the caller and responds with "Hello".
     *
     * SecurityService that is Autowired will provide access to the security context of the caller. It has methods like isAuthenticated(),
     * getUserName() and getUserId() etc which returns the information based on the caller context.
     *
     * Methods in this class can declare HttpServletRequest, HttpServletResponse as input parameters to access the
     * caller's request/response objects respectively. These parameters will be injected when request is made (during API invocation).
     */
    public String uploadFileToPhotos(MultipartFile file){
        logger.info("*****upload file start****"+file);
        String uploadImageUrl="";
        try{
            logger.info("*****file.getInputStream()****"+file.getInputStream());
            logger.info("*****file.getOriginalFilename()****"+file.getOriginalFilename());
            
            s3Connector.uploadFileToS3(file.getInputStream(),PHOTOS_PREFIX+"/"+file.getOriginalFilename(), null);
            uploadImageUrl="https://"+S3_BUCKET_NAME+"."+S3_REGION_NAME+"/"+PHOTOS_PREFIX+"/"+file.getOriginalFilename();
        } catch (IOException e) {
            throw new RuntimeException("Exception occurred while uploading file: "+e);
        }
        return uploadImageUrl;
    }

    public String uploadFileToIcons(MultipartFile file){
        logger.info("*****upload file start****"+file);
        String uploadImageUrl="";
        try{
            logger.info("*****file.getInputStream()****"+file.getInputStream());
            logger.info("*****file.getOriginalFilename()****"+file.getOriginalFilename());
            
            s3Connector.uploadFileToS3(file.getInputStream(),ICONS_PREFIX+"/"+file.getOriginalFilename(), null);
            uploadImageUrl="https://"+S3_BUCKET_NAME+"."+S3_REGION_NAME+"/"+ICONS_PREFIX+"/"+file.getOriginalFilename();
        } catch (IOException e) {
            throw new RuntimeException("Exception occurred while uploading file: "+e);
        }
        return uploadImageUrl;
    }

    public String uploadFileToSpecifiedDirectory(MultipartFile file, String directory){
        logger.info("*****upload file start****"+file);
        String uploadImageUrl="";
        try{
            logger.info("*****file.getInputStream()****"+file.getInputStream());
            logger.info("*****file.getOriginalFilename()****"+file.getOriginalFilename());
            
            s3Connector.uploadFileToS3(file.getInputStream(),directory+"/"+file.getOriginalFilename(), null);
            uploadImageUrl="https://"+S3_BUCKET_NAME+"."+S3_REGION_NAME+"/"+directory+"/"+file.getOriginalFilename();
        } catch (IOException e) {
            throw new RuntimeException("Exception occurred while uploading file: "+e);
        }
        return uploadImageUrl;
    }
    
    //to upload either single or multiple files at given path
    public String uploadFilesToS3(String folderPath,MultipartFile[] files){
        try {
            List<File> fileList = new ArrayList<>();
            for (MultipartFile multipartFile : files) {
                File file = convertMultipartFileToFile(multipartFile);
                if (file != null) {
                    fileList.add(file);
                }
            }
            //logger.info("filesList {}"+fileList);
            s3Connector.bulkUploadToS3(folderPath, fileList, null);
            logger.info("success");
            for (File file : fileList) {
                if (file.exists()) {
                    file.delete();
                }
            }
            return "uploaded";
        }catch(Exception e){
            return "error**"+e.getMessage();
        }
    }

    public String uploadFilesFromCsvToS3(String folderName, MultipartFile csvFile) {
        List<File> fileList = new ArrayList<>();
        try (CSVReader csvReader = new CSVReader(new InputStreamReader(csvFile.getInputStream()))) {
            String[] nextLine;
            while ((nextLine = csvReader.readNext()) != null) {
                for (String filePath : nextLine) {
                    String formattedPath = filePath.trim().replace("\\", "/");
                    File file = new File(formattedPath);
                    if (file.exists()) {
                        fileList.add(file);
                    } else {
                        logger.info("File not found:{}",filePath);
                    }
                }
            }
            logger.info("fileList**",fileList);
            s3Connector.bulkUploadToS3(folderName, fileList, null);
            return "CSV file paths uploaded successfully";
        } catch (IOException | CsvException e) {
            return e.getMessage();
        }
    }

    public List<AWSS3ObjectSummary> listObjects(){
        return s3Connector.listS3Objects();
    
    }

    public List<S3ObjectSummaryWrapper> filterObjectsByFolders(String folderPath){
        String objectBasePath = "https://" + S3_BUCKET_NAME + "." + S3_REGION_NAME + "/";
        List<AWSS3ObjectSummary> allObjects = s3Connector.listS3ObjectsByFolderPath(folderPath);
        return allObjects.stream()
            .map(object -> {
                String type = object.getSize()==0 ? "Folders":"Files";
            if (object.getSize() != 0) {
                String keyWithPath = objectBasePath + object.getKey();
                object.setKey(keyWithPath);
            }
            return new S3ObjectSummaryWrapper(object, type);
        })
        .sorted((o1,o2)->Long.compare(o1.getSize(),o2.getSize()))
        .collect(Collectors.toList());
    }

    public List<S3ObjectSummaryWrapper> listRootLevelFoldersObjects() {
        String objectBasePath = "https://" + S3_BUCKET_NAME + "." + S3_REGION_NAME + "/";
        List<AWSS3ObjectSummary> allObjects = s3Connector.listS3Objects();
        logger.info("allobjects:{}",allObjects);
        return allObjects.stream()
        .filter(object -> {
            String key = object.getKey();
            long size=object.getSize();
            int slashCount = key.length() - key.replace("/", "").length();
            return key.equals("/") || slashCount == 0 || (slashCount == 1 && key.endsWith("/"));
        })
        .map(object -> {
            logger.info("textObject"+object);
            String type = object.getSize()==0 ? "Folders":"Files";
            if (object.getSize() != 0) {
                String keyWithPath = objectBasePath + object.getKey();
                object.setKey(keyWithPath);
            }
            return new S3ObjectSummaryWrapper(object, type);
        })
        .sorted((o1,o2)->Long.compare(o1.getSize(),o2.getSize()))
        .collect(Collectors.toList());
    }

    // To list all the folders (includes nested folders) and object
    public List listAllFoldersWithObjects() {
        String objectBasePath = "https://"+S3_BUCKET_NAME+"."+S3_REGION_NAME+"/";
        List<AWSS3ObjectSummary> objectSummaryList = listObjects();
        Set<String> folderSet = new HashSet<>();
        Map<String, List<Map<String, Object>>> folderMap = new HashMap<>();
        List<String> rootObjects = new ArrayList<>();


        for (AWSS3ObjectSummary objectSummary : objectSummaryList) {
            String key = objectSummary.getKey();

            if (key.endsWith("/")) {
                // Checking folder or not, If the key ends with a '/', it is a folder.
                folderSet.add(key);
            } else {
                String extension = key.substring(key.lastIndexOf('.') + 1).toLowerCase();
                boolean isFile = !extensionContainsAny(extension);
                Map<String, Object> objectDetails = new HashMap<>();
                objectDetails.put("object_path", objectBasePath + key);
                objectDetails.put("isFile", isFile);
                // Extract folder path from key and add to folderMap
                int lastSlashIndex = key.lastIndexOf('/');
                if (lastSlashIndex > 0) {
                    String folderPath = key.substring(0, lastSlashIndex + 1);
                    folderSet.add(folderPath);

                    String objectName = key.substring(lastSlashIndex + 1);
                    folderMap.computeIfAbsent(folderPath, folderPathKey -> new ArrayList<>()).add(objectDetails);
                } else {
                    //If obbject are dirctly inthe rrot folder
                    rootObjects.add(objectDetails+key);
                }
            }
        }

        List folderList = new ArrayList<>();
        for (String folder : folderSet) {
            Map<String, Object> folderDetails = new HashMap<>();
            folderDetails.put("folder_path", folder);
            folderDetails.put("folder_name", extractFolderName(folder));
            folderDetails.put("uploadedObjects", folderMap.getOrDefault(folder, new ArrayList<>()));
            folderList.add(folderDetails);
        }
        if (!rootObjects.isEmpty()) {
            Map<String, Object> rootFolderDetails = new HashMap<>();
            rootFolderDetails.put("folder_path", "");
            rootFolderDetails.put("folder_name", "root");
            rootFolderDetails.put("uploadedObjects",rootObjects);
            folderList.add(rootFolderDetails);
        }
        return folderList;
    }


    public String createFolderInS3(String folderName){
        try{
            s3Connector.createFolderInS3(folderName);
            return "created successfully";
        }catch(Exception e){
            return e.getMessage();
        }
       
    }

    public DownloadResponse downloadFile(String s3KeyName){
        logger.info("*****downloadFile start****");
        try{
            OutputStream data= s3Connector.downloadFile(s3KeyName);
            DownloadResponse downloadResponse=new DownloadResponse();
            ByteArrayOutputStream outStream = (ByteArrayOutputStream)data;
            downloadResponse.setContents(new ByteArrayInputStream(outStream.toByteArray()));
            downloadResponse.setInline(false);
            downloadResponse.setFileName(s3KeyName);
            return downloadResponse;
            }catch(IOException e){
                throw new RuntimeException("Exception occurred while downloading file"+e);
            }
        }         
    
    public void deleteFolder(String folderName){
        s3Connector.deleteFolderInS3(folderName);
    }

    public void deleteFile(String s3KeyName){
        logger.info("*****deleteFile start****");
        s3Connector.deleteFile(s3KeyName);
    }
 
    private File convertMultipartFileToFile(MultipartFile multipartFile) {
        File convFile = new File(System.getProperty("java.io.tmpdir") + "/" + multipartFile.getOriginalFilename());
        try (FileOutputStream fos = new FileOutputStream(convFile)) {
            fos.write(multipartFile.getBytes());
            return convFile;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    private String extractFolderName(String folderPath) {
        if (folderPath.endsWith("/")) {
            folderPath = folderPath.substring(0, folderPath.length() - 1);
        }
        int lastSlashIndex = folderPath.lastIndexOf('/');
        return folderPath.substring(lastSlashIndex + 1);
    }

    private boolean extensionContainsAny(String extension) {
        return IMAGE_EXTENSIONS.stream().anyMatch(extension::contains);
    }

    /*
    Variables.stvS3Dedtails.dataSet.bucketName
    Variables.stvS3Dedtails.dataSet.s3_region
    */
    /*public String getResourceUrl(String bucketName, String key) {
        try {
            return getUrl(bucketName, key).toString();
            //return getAmazonS3Client().getUrl(getBucketName(), getKey());
            return '';
        } catch ( IOException e ) {
            return null;
        }
        return getUrl(bucketName, key).toString();
    }*/

    //to list all folders
    /*
    public List<String> listAllFolders() {
        List<AWSS3ObjectSummary> objectSummaries = listObjects();
        Set<String> folderNames = new HashSet<>();

        for (AWSS3ObjectSummary objectSummary : objectSummaries) {
            String key = objectSummary.getKey();
            String[] segments = key.split("/");

            StringBuilder folderPathBuilder = new StringBuilder();
            for (int i = 0; i < segments.length - 1; i++) { 
                String segment = segments[i];
                if (!segment.isEmpty()) {
                    folderPathBuilder.append(segment).append("/");
                    folderNames.add(folderPathBuilder.toString());
                }
            }
        }

        // Convert the set of folder paths to a list for easier handling
        List<String> flattenedFolders = new ArrayList<>(folderNames);
        return flattenedFolders;
    }
    */

}
